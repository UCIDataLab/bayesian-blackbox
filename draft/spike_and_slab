class SpikeAndBetaSlab(Model):
    """
    Spike(on diagonal) and slab (beta distribution) for modeling calibration of the model.

    WARNING: Arrays passed to constructor are copied!

    Parameters
    ==========
    k: int, number of bins
    prior_mu: np.ndarray (k, ), weight on the spike component for each bin
    prior_alpha: np.ndarray (k, ), alpha parameter of the Beta distribution for each bin
    prior_beta: np.ndarray (k, ), beta parameter of the Beta distribution for each bin
    """

    def __init__(self, k: int, prior_mu: None, prior_alpha: None, prior_beta: None):

        # constants
        self._k = k
        self._theta_0 = np.array([(i + 0.5) / k for i in range(k)])  # spike on diagonal

        # parameters to update:
        self._mu = None  # weight on the spike component, reflects how calibrated the model is
        self._alpha = None  #
        self._beta = None

        if prior_mu is None:
            self._mu = np.ones((k,)) * 0.5
        else:
            self._mu = np.copy(prior_mu)

        if prior_alpha is None:
            self._alpha = np.ones((k,)) * 0.5
        else:
            self._alpha = np.copy(prior_alpha)

        if prior_beta is None:
            self._beta = np.ones((k,)) * 0.5
        else:
            self._beta = np.copy(prior_beta)

    def update(self, category: int, observation: bool):
        """Updates the posterior: of the SpikeAndBetaSlab-Bernoulli model with one observation."""
        if observation:
            self._mu[category] = (self._mu[category] * self._theta_0[category]) / (
                    self._mu[category] * self._theta_0[category] + 1 - self._mu[category])
            self._alpha[category] += 1
        else:
            self._mu[category] = (self._mu[category] * (1 - self._theta_0[category])) / (
                    self._mu[category] * (1 - self._theta_0[category]) + 1 - self._mu[category])
            self._beta[category] += 1

    def _binom(n: int, k: int):
        return math.factorial(n) // math.factorial(k) // math.factorial(n - k)

    def update_batch(self, category: int, n: int, k: int):
        """Updates the posterior of the SpikeAndBetaSlab-Binomial model with k out of n positive observations in category"""
        self._mu[category] = 1 - (1 - self._mu[category]) \
                             / (self._mu[category] * _binom(n, k) * self._theta_0[category] ** k * (
                1 - self._theta_0[category]) ** (
                                        n - k) + 1 - self._mu[category])
        self._alpha[category] += k
        self._beta[category] += n - k

    @property
    def theta(self):
        """Return the mean of each bin"""
        return self._mu * self._theta_0 + (1 - self._mu) * self._alpha / (self._alpha + self._beta)
